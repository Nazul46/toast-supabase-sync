# -*- coding: utf-8 -*-
"""Baby_Acapulco_Power BI_Daily.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kjGONiUJBokrYTXtkCh1Vxj_0x5z4SXv
"""

from supabase import create_client
import requests
import datetime
import pytz

# ---------- CONFIGURATION ----------
SUPABASE_URL = "https://grzslnrsrdxywilzhmdf.supabase.co"
SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdyenNsbnJzcmR4eXdpbHpobWRmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI3MDMyNDAsImV4cCI6MjA2ODI3OTI0MH0.qWpAlLM9Y5RAvSSfDpG_cANpilu6Ui1Kq-od0fcceMA"
supabase = create_client(SUPABASE_URL, SUPABASE_KEY)

RESTAURANT_ID = "50938580-a665-4908-8f76-751f2ea53009"
TOAST_CLIENT_ID = "Os6cEHukLlZG4nsB9L9yAw5ClYYNWr1r"
TOAST_CLIENT_SECRET = "InK0V7Kk26xAt3ZAVk_A-tNYszBQM7rf2t31jpmuxwgwhGIRxYGryB93H1sRHb0s"
TOAST_API = "https://ws-api.toasttab.com"

# ---------- AUTHENTICATE ----------
try:
    auth_response = requests.post(
        f"{TOAST_API}/authentication/v1/authentication/login",
        json={
            "userAccessType": "TOAST_MACHINE_CLIENT",
            "clientId": TOAST_CLIENT_ID,
            "clientSecret": TOAST_CLIENT_SECRET
        }
    )
    auth_response.raise_for_status()
    access_token = auth_response.json()['token']['accessToken']
    headers = {
        "Authorization": f"Bearer {access_token}",
        "Toast-Restaurant-External-ID": RESTAURANT_ID
    }
    print("‚úÖ Authenticated successfully!")
except Exception as e:
    raise SystemExit(f"‚ùå Authentication failed: {e}")

# ---------- TIME RANGE ----------
central = pytz.timezone("America/Chicago")
now_ct = datetime.datetime.now(central)
start_time_ct = (now_ct - datetime.timedelta(days=1)).replace(hour=8, minute=0, second=0, microsecond=0)
end_time_ct = now_ct.replace(hour=8, minute=0, second=0, microsecond=0)

start_date = start_time_ct.astimezone(pytz.utc).strftime("%Y-%m-%dT%H:%M:%S.000+0000")
end_date = end_time_ct.astimezone(pytz.utc).strftime("%Y-%m-%dT%H:%M:%S.000+0000")

# ---------- UTILITY UPSERT FUNCTION ----------
def try_upsert(table_name, rows, conflict_key):
    if not rows:
        print(f"‚ö†Ô∏è No rows to upload for {table_name}")
        return
    try:
        supabase.table(table_name).upsert(rows, on_conflict=[conflict_key]).execute()
        print(f"‚úÖ Uploaded {len(rows)} rows to {table_name}")
    except Exception as e:
        print(f"‚ùå Error uploading to {table_name}: {e}")

# ---------- FETCH & UPSERT EMPLOYEES ----------
try:
    print("üì• Fetching employees...")
    resp = requests.get(f"{TOAST_API}/labor/v1/employees", headers=headers)
    resp.raise_for_status()
    employees = resp.json()
    rows = [{
        "guid": emp.get("guid"),
        "first_name": emp.get("firstName", ""),
        "last_name": emp.get("lastName", ""),
        "email": emp.get("email", ""),
        "external_employee_id": emp.get("externalEmployeeId") or emp.get("externalId"),
        "is_active": not emp.get("deleted", False)
    } for emp in employees if emp.get("guid")]
    try_upsert("toast_employees_baby_acapulco", rows, "guid")
except Exception as e:
    print(f"‚ùå Error processing employees: {e}")

# ---------- FETCH & UPSERT JOBS ----------
try:
    print("üì• Fetching job titles...")
    resp = requests.get(f"{TOAST_API}/labor/v1/jobs", headers=headers)
    resp.raise_for_status()
    jobs = resp.json()
    rows = [{
        "guid": job.get("guid"),
        "title": job.get("title"),
        "is_deleted": job.get("deleted", False)
    } for job in jobs if job.get("guid")]
    try_upsert("toast_jobs_baby_acapulco", rows, "guid")
except Exception as e:
    print(f"‚ùå Error processing jobs: {e}")

# ---------- FETCH & UPSERT TIME ENTRIES ----------
try:
    print(f"üì• Fetching time entries from {start_date} to {end_date}...")
    resp = requests.get(
        f"{TOAST_API}/labor/v1/timeEntries",
        headers=headers,
        params={"restaurantGuid": RESTAURANT_ID, "startDate": start_date, "endDate": end_date}
    )
    resp.raise_for_status()
    entries = resp.json()
    print(f"‚úÖ Retrieved {len(entries)} time entries.")
    rows = []
    for entry in entries:
        if entry.get("guid"):
            rows.append({
                "guid": entry.get("guid"),
                "employee_guid": entry.get("employeeReference", {}).get("guid"),
                "job_guid": entry.get("jobReference", {}).get("guid"),
                "in_time": entry.get("inDate"),
                "out_time": entry.get("outDate"),
                "regular_hours": entry.get("regularHours"),
                "overtime_hours": entry.get("overtimeHours"),
                "hourly_wage": entry.get("hourlyWage"),
                "total_tips": (entry.get("nonCashTips") or 0) + (entry.get("cashGratuityServiceCharges") or 0),
                "non_cash_sales": entry.get("nonCashSales"),
                "cash_sales": entry.get("cashSales"),
            })
    try_upsert("toast_time_entries_baby_acapulco", rows, "guid")
except Exception as e:
    print(f"‚ùå Error processing time entries: {e}")

# ---------- FETCH & UPSERT STOCK INVENTORY ----------
try:
    print("üì¶ Fetching inventory stock items...")
    resp = requests.get(f"{TOAST_API}/stock/v1/inventory", headers=headers)
    resp.raise_for_status()
    items = resp.json()
    rows = [{
        "guid": item.get("guid"),
        "item_guid_validity": item.get("itemGuidValidity"),
        "status": item.get("status"),
        "quantity": item.get("quantity"),
        "multi_location_id": item.get("multiLocationId"),
        "version_id": item.get("versionId"),
    } for item in items if item.get("guid")]
    try_upsert("toast_stock_inventory_baby_acapulco", rows, "guid")
except Exception as e:
    print(f"‚ùå Error processing inventory: {e}")

# ---------- FETCH & INSERT ORDERS ----------
def fetch_and_upload_orders(headers, supabase):
    print("üìÖ Getting orders from 8 AM yesterday to 8 AM today (Central Time)...")

    # ‚¨áÔ∏è Use aligned 8 AM CT cutoff converted to UTC
    end = end_time_ct.astimezone(pytz.utc)

    total_uploaded = 0
    total_skipped = 0
    total_failed = 0

    for i in range(24):
        chunk_end = end - datetime.timedelta(hours=i)
        chunk_start = chunk_end - datetime.timedelta(hours=1)

        start_str = chunk_start.strftime('%Y-%m-%dT%H:%M:%S.000+0000')
        end_str = chunk_end.strftime('%Y-%m-%dT%H:%M:%S.000+0000')

        try:
            res = requests.get(
                f"{TOAST_API}/orders/v2/orders",
                headers=headers,
                params={
                    "startDate": start_str,
                    "endDate": end_str,
                    "limit": 100,
                    "orderStates": "PAID"
                }
            )
            res.raise_for_status()
            order_ids = res.json()

            if not isinstance(order_ids, list) or not order_ids:
                continue  # Skip empty chunks

            for order_id in order_ids:
                try:
                    detail_url = f"{TOAST_API}/orders/v2/orders/{order_id}"
                    detail_resp = requests.get(detail_url, headers=headers)
                    detail_resp.raise_for_status()
                    order = detail_resp.json()

                    check = order.get("checks", [{}])[0]
                    if not check:
                        total_skipped += 1
                        continue

                    row = {
                        "order_guid": order.get("guid"),
                        "check_guid": check.get("guid"),
                        "display_number": order.get("displayNumber"),
                        "source": order.get("source"),
                        "opened_date": check.get("openedDate"),
                        "paid_date": check.get("paidDate"),
                        "payment_status": check.get("paymentStatus"),
                        "amount": check.get("amount"),
                        "total_amount": check.get("totalAmount"),
                        "tax_amount": check.get("taxAmount"),
                        "voided": order.get("voided", False),
                        "number_of_guests": order.get("numberOfGuests"),
                        "created_date": order.get("createdDate"),
                        "modified_date": order.get("modifiedDate"),
                        "revenue_center_guid": order.get("revenueCenter", {}).get("guid"),
                        "server_guid": order.get("server", {}).get("guid"),
                    }

                    try:
                        supabase.table("toast_orders_baby_acapulco").insert(row).execute()
                        total_uploaded += 1
                    except Exception as db_err:
                        if "duplicate key value" in str(db_err):
                            total_skipped += 1
                        else:
                            total_failed += 1
                except Exception:
                    total_failed += 1

        except Exception:
            total_failed += 1

    print(f"\n‚úÖ Finished! {total_uploaded} uploaded, {total_skipped} skipped, {total_failed} failed.")

# ---------- MAIN ----------
fetch_and_upload_orders(headers, supabase)